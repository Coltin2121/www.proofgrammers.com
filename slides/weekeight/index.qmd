---
title: "Turing Reductions"
description: "Proving problems are hard using reduction techniques"
date: "2025-10-13"
date-format: long
author: Gregory M. Kapfhammer
execute:
  echo: true
format:
  live-revealjs:
    completion: true
    theme: default
    css: ../css/styles.css
    history: false
    scrollable: true
    transition: slide
    highlight-style: github
    footer: "Proofgrammers"
---

# Learning objectives

::: {.fragment .callout-note icon=true title="Learning Objectives for Theoretical Machines"}

- **CS-204-1**: Use both intuitive analysis and theoretical proof techniques to
correctly distinguish between problems that are tractable, intractable, and
uncomputable.
- **CS-204-2**: Correctly use one or more variants of the Turing machine (TM)
abstraction to both describe and analyze the solution to a computational
problem.
- **CS-204-3**: Correctly use one or more variants of the finite statement
machine (FSM) abstraction to describe and analyze the solution to a
computational problem.
- **CS-204-4**: Use a formal proof technique to correctly classify a problem
according to whether or not it is in the P, NP, NP-Hard, and/or NP-Complete
complexity class(es).
- **CS-204-5**: Apply insights from theoretical proofs concerning the limits of
either program feasibility or complexity to the implementation of both correct
and efficient real-world Python programs.

:::

# Reduction techniques, like Turing reduction, aid when proving that a problem is "hard"!

::: fragment

- "Reduction for hardness" helps with learning objective **CS-204-4**, in which
you learn how to prove a problem is uncomputable or otherwise "hard". Okay,
let's dive in!

:::
## Prove computational problem is hard

::: {.incremental style="margin-top: -0.5em; font-size: 0.9em;"}

- {{< iconify fa6-solid lightbulb >}} **Main goal**: Prove a problem is uncomputable
    - We suspect a problem cannot be solved by any algorithm
    - Need rigorous mathematical proof to establish this fact
    - Cannot just say "it seems hard" or "I can't think of a solution"

:::

::: {.fragment style="margin-top: -0.5em; font-size: 0.9em;"}

- {{< iconify fa6-solid gear >}} **Two proof approaches to try**
    - **Contradiction proof**: Prove uncomputability by contradiction
    - **Reduction proof**: Constructively transform a known hard problem $F$ to
    a new problem $G$, thereby showing that new problem $G$ is at least as hard
    as known problem $F$
    - **Let's explore how to perform a reduction proof**!

:::

## Why do reductions work?

::: {.incremental style="margin-top: -0.5em; font-size: 0.85em;"}

- We have a problem $F$ that is already proven to be uncomputable
- We want to prove a new problem $G$ is also uncomputable
- Reduction from $F$ to $G$ means we can solve $F$ using a solution for $G$
- {{< iconify fa6-solid diagram >}} **Steps**: Proceed by contradiction to
prove reduction approach works
  - Assume $G$ is computable
  - Construct a reduction from $F$ to $G$ 
  - This means that $F$ is also computable
  - This contradicts the fact that $F$ is uncomputable
  - This means the initial assumption was incorrect
  - We can therefore conclude that $G$ is uncomputable

:::

## Example of Turing reduction concepts

![](07-reductions_0.png)

## Reduction as Python source code

```python
import utils; from utils import rf
from lastDigitIsEven import lastDigitIsEven 
def isOddViaReduction(inString):
    inStringPlusOne = int(inString) + 1
    return lastDigitIsEven(str(inStringPlusOne)) 

def testisOddViaReduction():
    testVals = [('-2', 'no'),
                ('0', 'no'),
                ('2', 'no'),
                ('3742788', 'no'),
                ('-1', 'yes'),
                ('1', 'yes'),
                ('3', 'yes'),
                ('17', 'yes'),
                ('3953969', 'yes'),
                ]
    for (inString, solution) in testVals:
        val = isOddViaReduction(inString)
        utils.tprint(inString, ':', val)
        assert val == solution
```

::: {.fragment style="margin-top: -0.25em; font-size: 0.815em;"}

- `isOddViaReduction` uses `lastDigitIsEven` to solve the `isOdd` problem
- `isOddViaReduction` solves `IsOdd` by reduction it to `LastDigitIsEven`

:::

## What is a Turing reduction?

::: {.incremental style="margin-top: -0.5em; font-size: 0.825em;"}

- {{< iconify fa6-solid definition >}} **Formal definition**: 
    - Let $F$ and $G$ be computational problems
    - $F$ has a Turing reduction to $G$ if can solve $F$ using a program for $G$
    - We write this as $F \leq_T G$ (read this notation as "$F$ reduces to $G$")

:::

::: {.fragment .fade .boxed-content style="margin-top: -0.25em; font-size: 0.85em;"}

- {{< iconify fa6-solid lightbulb >}} **Intuitive meanings**:
    - "$F$ is easier than $G$" or "$F$ is no harder than $G$"
    - If $G$ is solvable, then $F$ is automatically solvable
    - If $F$ is unsolvable, then $G$ must also be unsolvable
    - Visually, write the notation $F \leq_T G$ as $F \rightarrow G$ in a diagram

:::

## `YesOnString` $\rightarrow$ `ContainsGAGA`

::: {.incremental style="margin-top: -0.5em; font-size: 0.8em;"}

- {{< iconify fa6-solid target >}} **Goal**: Prove `ContainsGAGA` is uncomputable
- {{< iconify fa6-solid known >}} **Known fact**: `YesOnString` is uncomputable
- {{< iconify fa6-solid strategy >}} **Strategy**: Show `YesOnString` $\leq_T$ `ContainsGAGA`

:::

::: {.fragment style="margin-top: -0.5em; font-size: 0.8em;"}

- {{< iconify fa6-solid gear >}} **Problem definitions**:
    - `YesOnString`: Given program $P$ and input $I$, does $P(I)=$ "yes"?
    - `ContainsGAGA`: Given program $P$ and input $I$, does $P(I)$ contain the
    string "GAGA"?
- {{< iconify fa6-solid plan >}} **Reduction strategy**:
    - Transform any instance of `YesOnString` into an instance of `ContainsGAGA`
    (i.e., `ContainsGAGA` will "call" `YesOnString`)
    - Use "oracle" for `ContainsGAGA` to solve `YesOnString`

:::

## Reduction as Python source code

```python
import utils; from utils import rf
from GAGAOnString import GAGAOnString # oracle function  
def yesViaGAGA(progString, inString):
    singleString = utils.ESS(progString, inString)
    return GAGAOnString(rf('alterYesToGAGA.py'), singleString) 

def testYesViaGAGA():
    testvals = [
        ('containsGAGA.py', 'TTTTGAGATT', 'yes'),
        ('containsGAGA.py', 'TTTTGAGTT', 'no'),
        ('isEmpty.py', '', 'yes'),
        ('isEmpty.py', 'x', 'no'),
    ]
    for (filename, inString, solution) in testvals:
        val = yesViaGAGA(rf(filename), inString)
        utils.tprint(filename + ":", val)
        assert val == solution
```

::: {.fragment style="margin-top: 0em; font-size: 0.85em;"}

- {{< iconify fa6-solid code >}} **Key idea**: Solve the `YesOnString` problem
using an "oracle" for `ContainsGAGA`, meaning we can solve known problem with
new one

:::

## Why does this prove that `ContainsGAGA` is uncomputable?

::: {.incremental style="margin-top: -0.5em; font-size: 0.85em;"}

- {{< iconify fa6-solid gears >}} **Step 1**: Assume `ContainsGAGA` is
computable
- {{< iconify fa6-solid gears >}} **Step 2**: Then `YesOnString` is computable
(via our reduction)
- {{< iconify fa6-solid gears >}} **Step 3**: But `YesOnString` is uncomputable,
which we have previously proven in a separate proof by contradiction!

:::

::: {.fragment .boxed-content style="margin-top: 0em; font-size: 0.85em;"}

- **Contradiction**: Cannot have both computable and uncomputable
- **Realization**: Our initial assumption was wrong
- **Conclusion**: `ContainsGAGA` must be uncomputable
- **This completes the proof that `ContainsGAGA` is uncomputable**!

:::

## Tree of uncomputable problems

::: {.fragment style="margin-top: -0.5em; font-size: 0.8em;"}

- {{< iconify fa6-solid tree >}} **Starting point**: `YesOnString`, previously proven uncomputable 

- {{< iconify fa6-solid gears >}} **First level reductions**:
    - {{< iconify fa6-solid branch >}} **Reduce to**: `YesOnEmpty` (does $P(\epsilon)=$ "yes"?)
    - {{< iconify fa6-solid branch >}} **Reduce to**: `YesOnAll` (does $P(I)=$ "yes" for all $I$?)
    - {{< iconify fa6-solid branch >}} **Reduce to**: `YesOnSome` (does $P(I)=$ "yes" for some $I$?)
    - {{< iconify fa6-solid branch >}} **Reduce to**: `ContainsGAGA` (does $P(I)$ output contain "GAGA"?)
- {{< iconify fa6-solid gears >}} **Second level reductions**:
    - {{< iconify fa6-solid branch >}} **From halting**: `HaltsOnString`, `HaltsOnEmpty`, `HaltsOnAll`
    - {{< iconify fa6-solid branch >}} **From counting**: `NumCharsOnString`, `NumStepsOnString`

- {{< iconify fa6-solid lightbulb >}} **Next question**: What are the properties of Turing reductions?
- {{< iconify fa6-solid tree >}} **And, finally, how can we visualize a tree of reductions**?

:::

## Properties of Turing reductions

::: {.incremental style="margin-top: -0.5em; font-size: 0.85em;"}

- **Transitivity property:**
    - {{< iconify fa6-solid chain >}} **Chain reductions**: If $F \leq_T G$ and $G
    \leq_T H$, then $F \leq_T H$
    - {{< iconify fa6-solid compose >}} **Composition**: Solve $F$ using $G$ oracle,
    solve $G$ using $H$ oracle
    - {{< iconify fa6-solid result >}} **Combined**: Can solve $F$ using $H$ oracle
    directly

:::

::: {.fragment .boxed-content style="margin-top: -0.25em; font-size: 0.8em;"}

- Importantly, all of these uncomputability proofs start from a single known
uncomputable problem, such as `YesOnString`!

-  **Building hierarchies**: Transitivity helps organize problems by hardness

- **Viewing hierarchies**: See the relationships between problems in a tree

- **Tree Interpretation**: Node at the top is the "starting point" of the
Turing reduction chain! Okay, let's see what this looks like!

:::

## Tree of uncomputable problems

![](07-reductions_5.png)

# What are different ways that you can express the tree's relationships?

::: {.incremental style="margin-top: -0.5em; font-size: 0.85em;"}

- `YesOnString` is at least as hard as `HaltsOnString`
- `HaltsOnString` is at least as hard as `HaltsOnEmpty`
- `HaltsOnString` is at least as hard as `NumStepsOnString`
- `YesOnString` is at least as hard as `HaltsOnEmpty`
- `YesOnString` is at least as hard as `NumStepsOnString`

:::

# Reductions in complexity theory

::: {.incremental style="margin-top: -0.5em; font-size: 0.85em;"}

- {{< iconify fa6-solid speed >}} **Polynomial-time reductions**: Used for
NP-completeness proofs
- {{< iconify fa6-solid limit >}} **Resource bounds**: Reduction must be
computed efficiently
- {{< iconify fa6-solid practical >}} **Practical implications**: Hard problems
remain hard under efficient reductions

:::

::: {.fragment style="margin-top: -0.5em; font-size: 0.85em;"}

- {{< iconify fa6-solid preview >}} **Coming attractions**:
    - **Chapter 8**: NP-completeness and polynomial reductions
    - **Chapter 9**: More complexity classes and their relationships
    - **Applications**: Real-world problems that are provably hard

:::

## Connection to software verification

::: {.incremental style="margin-top: -0.5em; font-size: 0.75em;"}

- {{< iconify fa6-solid bug >}} **Program analysis**: Many verification problems
are uncomputable
- {{< iconify fa6-solid approximation >}} **Practical solutions**: Use
approximation algorithms and heuristics
- {{< iconify fa6-solid tools >}} **Static analysis tools**: Work within
computable approximations

:::

## Key takeaways for proofgrammers

::: {.incremental style="margin-top: -0.5em; font-size: 0.85em;"}

- {{< iconify fa6-solid concept1 >}} **Turing reductions**: Systematic way to
prove problems uncomputable
- {{< iconify fa6-solid concept2 >}} **Oracle methodology**: Assume solution
exists to build contradiction
- {{< iconify fa6-solid concept3 >}} **Proof by contradiction**: Powerful
technique for impossibility results
- {{< iconify fa6-solid concept4 >}} **Problem hierarchies**: Organize
computational problems by difficulty

:::

## Practical skills developed

::: {.incremental style="margin-top: -0.5em; font-size: 0.85em;"}

- {{< iconify fa6-solid code >}} **Program transformation**: Modify programs to
change their behavior
- {{< iconify fa6-solid proof >}} **Reduction construction**: Build systematic
arguments for hardness
- {{< iconify fa6-solid reasoning >}} **Mathematical reasoning**: Apply formal
logic to computational problems

:::
