---
title: "Turing Reductions"
description: "Proving problems are hard using reduction techniques"
date: "2025-10-13"
date-format: long
author: Gregory M. Kapfhammer
execute:
  echo: true
format:
  live-revealjs:
    completion: true
    theme: default
    css: ../css/styles.css
    history: false
    scrollable: true
    transition: slide
    highlight-style: github
    footer: "Proofgrammers"
---

# Learning objectives

::: {.fragment .callout-note icon=true title="Learning Objectives for Theoretical Machines"}

- **CS-204-1**: Use both intuitive analysis and theoretical proof techniques to
correctly distinguish between problems that are tractable, intractable, and
uncomputable.
- **CS-204-2**: Correctly use one or more variants of the Turing machine (TM)
abstraction to both describe and analyze the solution to a computational
problem.
- **CS-204-3**: Correctly use one or more variants of the finite statement
machine (FSM) abstraction to describe and analyze the solution to a
computational problem.
- **CS-204-4**: Use a formal proof technique to correctly classify a problem
according to whether or not it is in the P, NP, NP-Hard, and/or NP-Complete
complexity class(es).
- **CS-204-5**: Apply insights from theoretical proofs concerning the limits of
either program feasibility or complexity to the implementation of both correct
and efficient real-world Python programs.

:::

# Reduction techniques, like Turing reduction, aid when proving that a problem is "hard"!

::: fragment

- "Reduction for hardness" helps with learning objective **CS-204-4**, in which
you learn how to prove a problem is uncomputable or otherwise "hard". Okay,
let's dive in!

:::
## Prove computational problem is hard

::: {.incremental style="margin-top: -0.5em; font-size: 0.9em;"}

- {{< iconify fa6-solid lightbulb >}} **Main goal**: Prove a problem is uncomputable
    - We suspect a problem cannot be solved by any algorithm
    - Need rigorous mathematical proof to establish this fact
    - Cannot just say "it seems hard" or "I can't think of a solution"

:::

::: {.fragment style="margin-top: -0.5em; font-size: 0.9em;"}

- {{< iconify fa6-solid gear >}} **Two proof approaches to try**
    - **Contradiction proof**: Prove uncomputability by contradiction
    - **Reduction proof**: Constructively transform a known hard problem $F$ to
    a new problem $G$, thereby showing that new problem $G$ is at least as hard
    as known problem $F$
    - **Let's explore how to perform a reduction proof**!

:::

## Why do reductions work?

::: {.incremental style="margin-top: -0.5em; font-size: 0.85em;"}

- We have a problem $F$ that is already proven to be uncomputable
- We want to prove a new problem $G$ is also uncomputable
- Reduction from $F$ to $G$ means we can solve $F$ using a solution for $G$
- {{< iconify fa6-solid diagram >}} **Steps**: Proceed by contradiction to
prove reduction approach works
  - Assume $G$ is computable
  - Construct a reduction from $F$ to $G$ 
  - This means that $F$ is also computable
  - This contradicts the fact that $F$ is uncomputable
  - This means the initial assumption was incorrect
  - We can therefore conclude that $G$ is uncomputable

:::

## Example of Turing reduction concepts

![](07-reductions_0.png)

## What is a Turing reduction?

::: {.incremental style="margin-top: -0.5em; font-size: 0.825em;"}

- {{< iconify fa6-solid definition >}} **Formal definition**: 
    - Let $F$ and $G$ be computational problems
    - $F$ has a Turing reduction to $G$ if can solve $F$ using a program for $G$
    - We write this as $F \leq_T G$ (read this notation as "$F$ reduces to $G$")

:::

::: {.fragment .fade .boxed-content style="margin-top: -0.25em; font-size: 0.85em;"}

- {{< iconify fa6-solid lightbulb >}} **Intuitive meanings**:
    - "$F$ is easier than $G$" or "$F$ is no harder than $G$"
    - If $G$ is solvable, then $F$ is automatically solvable
    - If $F$ is unsolvable, then $G$ must also be unsolvable
    - Visually, write the notation $F \leq_T G$ as $F \rightarrow G$ in a diagram

:::

## `YesOnString` $\rightarrow$ `ContainsGAGA`

::: {.incremental style="margin-top: -0.5em; font-size: 0.8em;"}

- {{< iconify fa6-solid target >}} **Goal**: Prove `ContainsGAGA` is uncomputable
- {{< iconify fa6-solid known >}} **Known fact**: `YesOnString` is uncomputable
- {{< iconify fa6-solid strategy >}} **Strategy**: Show `YesOnString` $\leq_T$ `ContainsGAGA`

:::

::: {.fragment style="margin-top: -0.5em; font-size: 0.8em;"}

- {{< iconify fa6-solid gear >}} **Problem definitions**:
    - `YesOnString`: Given program $P$ and input $I$, does $P(I)=$ "yes"?
    - `ContainsGAGA`: Given program $P$ and input $I$, does $P(I)$ contain the
    string "GAGA"?
- {{< iconify fa6-solid plan >}} **Reduction strategy**:
    - Transform any instance of `YesOnString` into an instance of `ContainsGAGA`
    (i.e., `ContainsGAGA` will call `YesOnString`)
    - Use oracle for `ContainsGAGA` to solve `YesOnString`

:::

## Reduction as Python source code

```python
import utils; from utils import rf
from GAGAOnString import GAGAOnString # oracle function  
def yesViaGAGA(progString, inString):
    singleString = utils.ESS(progString, inString)
    return GAGAOnString(rf('alterYesToGAGA.py'), singleString) 

def testYesViaGAGA():
    testvals = [
        ('containsGAGA.py', 'TTTTGAGATT', 'yes'),
        ('containsGAGA.py', 'TTTTGAGTT', 'no'),
        ('isEmpty.py', '', 'yes'),
        ('isEmpty.py', 'x', 'no'),
    ]
    for (filename, inString, solution) in testvals:
        val = yesViaGAGA(rf(filename), inString)
        utils.tprint(filename + ":", val)
        assert val == solution
```

::: {.fragment style="margin-top: -0.1em; font-size: 0.85em;"}

- {{< iconify fa6-solid code >}} **Key idea**: Solve the `YesOnString` problem
using an "oracle" for `ContainsGAGA`, meaning we can solve known problem with
new one

:::

## Why does this prove that `ContainsGAGA` is uncomputable?

::: {.incremental style="margin-top: -0.5em; font-size: 0.85em;"}

- {{< iconify fa6-solid gears >}} **Step 1**: Assume `ContainsGAGA` is
computable
- {{< iconify fa6-solid gears >}} **Step 2**: Then `YesOnString` is computable
(via our reduction)
- {{< iconify fa6-solid gears >}} **Step 3**: But `YesOnString` is uncomputable
(proven in Chapter 3)
- {{< iconify fa6-solid contradiction >}} **Contradiction**: Cannot have both
computable and uncomputable

:::

::: {.fragment style="margin-top: -0.5em; font-size: 0.85em;"}

- {{< iconify fa6-solid conclusion >}} **Conclusion**: Our assumption was wrong
- {{< iconify fa6-solid result >}} **Therefore**: `CONTAINSGAGA` must be uncomputable

:::

## The power of proof by contradiction

::: {.incremental style="margin-top: -0.5em; font-size: 0.85em;"}

- {{< iconify fa6-solid magic >}} **Elegant technique**: Assume opposite of what we want to prove
- {{< iconify fa6-solid chain >}} **Follow logical chain**: Use assumption to derive impossible conclusion
- {{< iconify fa6-solid boom >}} **Reach contradiction**: Shows assumption must be false

:::

# Building a tree of uncomputable problems

::: {.fragment style="margin-top: -0.5em; font-size: 0.85em;"}

- {{< iconify fa6-solid tree >}} **Starting point**: `YESONSTRING` (uncomputable by diagonalization)

:::

## First level reductions

::: {.incremental style="margin-top: -0.5em; font-size: 0.75em;"}

- {{< iconify fa6-solid branch >}} **Reduce to**: `YESONEMPTY` (does $P(\epsilon) = $ "yes"?)
- {{< iconify fa6-solid branch >}} **Reduce to**: `YESONALL` (does $P(I) = $ "yes" for all $I$?)
- {{< iconify fa6-solid branch >}} **Reduce to**: `YESONSOME` (does $P(I) = $ "yes" for some $I$?)
- {{< iconify fa6-solid branch >}} **Reduce to**: `CONTAINSGAGA` (does $P(I)$ output contain "GAGA"?)

:::

## Second level reductions

::: {.incremental style="margin-top: -0.5em; font-size: 0.75em;"}

- {{< iconify fa6-solid branch >}} **From halting**: `HALTSONSTRING`, `HALTSONEMPTY`, `HALTSONALL`
- {{< iconify fa6-solid branch >}} **From counting**: `NUMCHARSONSTRING`, `NUMSTEPSONSTRING`
- {{< iconify fa6-solid branch >}} **From analysis**: Does program compute constant function? Is program total?

:::

```{pyodide}
#| autorun: true
def reduce_yes_to_empty(prog_string, input_string):
    """Reduce YESONSTRING to YESONEMPTY."""
    # Create ignoreInput program that runs prog_string on input_string
    # regardless of what input it receives
    
    def ignore_input_program(any_input):
        # Ignore any_input, always run original computation
        return simulate_program(prog_string, input_string)
    
    # Oracle question: Does ignore_input_program("") output "yes"?
    # This is equivalent to: Does original program output "yes"?
    return yesonempty_oracle("ignore_input_code", "")

def yesonempty_oracle(prog_str, empty_input):
    """Oracle for YESONEMPTY problem."""
    return "yes"  # Pretend oracle result

print("YESONSTRING reduces to YESONEMPTY via ignoreInput technique")
result = reduce_yes_to_empty("sample_prog", "sample_input")
print(f"Reduction result: {result}")
```

::: {.fragment style="font-size: 0.9em;"}

{{< iconify fa6-solid cascade >}} **Cascade effect**: Each reduction proves another problem uncomputable

:::

# Properties of Turing reductions

## Transitivity

::: {.incremental style="margin-top: -0.5em; font-size: 0.85em;"}

- {{< iconify fa6-solid chain >}} **Chain reductions**: If $F \leq_T G$ and $G \leq_T H$, then $F \leq_T H$
- {{< iconify fa6-solid compose >}} **Composition**: Solve $F$ using $G$ oracle, solve $G$ using $H$ oracle
- {{< iconify fa6-solid result >}} **Combined**: Can solve $F$ using $H$ oracle directly

:::

## Reflexivity and antisymmetry

::: {.incremental style="margin-top: -0.5em; font-size: 0.85em;"}

- {{< iconify fa6-solid self >}} **Reflexive**: $F \leq_T F$ (trivial - solve $F$ using $F$ oracle)
- {{< iconify fa6-solid equal >}} **Antisymmetric**: If $F \leq_T G$ and $G \leq_T F$, then $F$ and $G$ are equivalent

:::

```{pyodide}
#| autorun: true
def demonstrate_transitivity():
    """Show how reduction chains work."""
    print("Reduction chain: F ≤_T G ≤_T H")
    
    def solve_F_via_H():
        print("  F calls G oracle...")
        def solve_G_via_H():
            print("    G calls H oracle...")
            h_result = "H_solution"
            print(f"    H oracle returns: {h_result}")
            return f"G_processed_{h_result}"
        
        g_result = solve_G_via_H()
        print(f"  G oracle returns: {g_result}")
        return f"F_processed_{g_result}"
    
    final_result = solve_F_via_H()
    print(f"Final F result: {final_result}")
    print("\nConclusion: F ≤_T H via composition")

demonstrate_transitivity()
```

::: {.fragment style="font-size: 0.9em;"}

{{< iconify fa6-solid hierarchy >}} **Building hierarchies**: Transitivity helps organize problems by hardness

:::

# Reductions in complexity theory

::: {.incremental style="margin-top: -0.5em; font-size: 0.85em;"}

- {{< iconify fa6-solid speed >}} **Polynomial-time reductions**: Used for NP-completeness proofs
- {{< iconify fa6-solid limit >}} **Resource bounds**: Reduction must be computed efficiently
- {{< iconify fa6-solid practical >}} **Practical implications**: Hard problems remain hard under efficient reductions

:::

::: {.fragment style="margin-top: -0.5em; font-size: 0.85em;"}

- {{< iconify fa6-solid preview >}} **Coming attractions**:
    - **Chapter 8**: NP-completeness and polynomial reductions
    - **Chapter 9**: More complexity classes and their relationships
    - **Applications**: Real-world problems that are provably hard

:::

## Connection to software verification

::: {.incremental style="margin-top: -0.5em; font-size: 0.75em;"}

- {{< iconify fa6-solid bug >}} **Program analysis**: Many verification problems are uncomputable
- {{< iconify fa6-solid approximation >}} **Practical solutions**: Use approximation algorithms and heuristics
- {{< iconify fa6-solid tools >}} **Static analysis tools**: Work within computable approximations

:::

# Key takeaways for proofgrammers

## Essential concepts mastered today

::: {.incremental style="margin-top: -0.5em; font-size: 0.85em;"}

- {{< iconify fa6-solid concept1 >}} **Turing reductions**: Systematic way to prove problems uncomputable
- {{< iconify fa6-solid concept2 >}} **Oracle methodology**: Assume solution exists to build contradiction
- {{< iconify fa6-solid concept3 >}} **Proof by contradiction**: Powerful technique for impossibility results
- {{< iconify fa6-solid concept4 >}} **Problem hierarchies**: Organize computational problems by difficulty

:::

## Practical skills developed

::: {.incremental style="margin-top: -0.5em; font-size: 0.85em;"}

- {{< iconify fa6-solid code >}} **Program transformation**: Modify programs to change their behavior
- {{< iconify fa6-solid proof >}} **Reduction construction**: Build systematic arguments for hardness
- {{< iconify fa6-solid reasoning >}} **Mathematical reasoning**: Apply formal logic to computational problems

:::
