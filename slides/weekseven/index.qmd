---
title: "Universal Computer Programs"
description: "Programs that can do anything"
date: "2025-10-06"
date-format: long
author: Gregory M. Kapfhammer
execute:
  echo: true
format:
  live-revealjs:
    completion: true
    theme: default
    css: ../css/styles.css
    history: false
    scrollable: true
    transition: slide
    highlight-style: github
    footer: "Proofgrammers"
---

# What makes a program "universal"? Can any program execute any other program?

::: fragment

- {{< iconify fa6-solid robot >}} Explore universal Python programs and Turing machines
- {{< iconify fa6-solid code >}} Develop automated program alteration techniques

:::

## One programs runs another

::: incremental

- **Python program**: Python interpreter runs any program
- **Web browser**:
    - Browser renders any web page
    - Browser runs any JavaScript program
    - Browser runs any WebAssembly program
- **Operating system**: runs any executable program
- Isn't it magical that one program can run another?
- Why is this possible? What are the benefits?

:::

## Running Python programs

::: {.incremental style="margin-top: -0.5em; font-size: 0.825em;"} 

- {{< iconify fa6-brands python >}} **Python's built-in capability**
    - `exec()` function executes Python code from strings
    - Any programming language can execute its own code
    - Python makes this particularly easy to implement
    - Foundation for creating universal programs

:::

::: {.incremental style="margin-top: -0.5em; font-size: 0.825em;"}

- {{< iconify fa6-solid lightbulb >}} **Simple example in action**
    - `command = "print('abc', 5+2)"`
    - `exec(command)` produces output `abc 7`
    - The parameter `5+2` gets evaluated to `7`
    - String becomes executable Python code

:::

## Running Python code strings

```{python}
#| autorun: true
#| max-lines: 15
def universal(prog_string, in_string):
    """Execute any Python program with any input."""
    # Execute the definition of the function in prog_string
    # This defines the function but doesn't invoke it
    namespace = {}
    exec(prog_string, namespace)
    # Extract function name from the program string
    # Find the first callable function in namespace
    for name, obj in namespace.items():
        if callable(obj) and not name.startswith('_'):
            return obj(in_string)
    return "No function found"

# Test the universal program
prog = """
def contains_gaga(inString):
    return 'yes' if 'GAGA' in inString else 'no'
"""

print(universal(prog, 'GTTGAGA'))  # Should output: yes
print(universal(prog, 'GTTAA'))    # Should output: no
```

::: {.fragment .fade style="margin-top: -0.35em; font-size: 0.85em;"}

- **Key insight**: Universal programs can simulate *any* other program!

:::

## What makes this universal?

::: {.incremental style="margin-top: -0.5em; font-size: 0.825em;"} 

- {{< iconify fa6-solid infinity >}} **Unlimited simulation power**
    - Can execute any syntactically valid Python program
    - Works with programs of arbitrary complexity
    - No restrictions on program logic or structure
    - Only limited by Python language capabilities

:::

::: {.incremental style="margin-top: -0.5em; font-size: 0.825em;"}

- {{< iconify fa6-solid gears >}} **Three-step process**
    - **Define**: `exec()` creates function in memory
    - **Extract**: Get reference to the newly defined function  
    - **Execute**: Call function with provided input
    - Result matches original program's behavior

:::

## Universal Turing machines

::: {.incremental style="margin-top: -0.5em; font-size: 0.825em;"} 

- {{< iconify fa6-solid brain >}} **Turing's 1936 breakthrough**
    - Universal Turing machine $U$ can simulate any machine $M$
    - Takes input $\text{str}(M, I) = \text{ESS}(\text{desc}(M), I)$
    - Encodes machine description with input string
    - $U(\text{str}(M, I)) = M(I)$ for all machines and inputs

:::

::: {.incremental style="margin-top: -0.5em; font-size: 0.825em;"}

- {{< iconify fa6-solid gear >}} **Practical construction approach**
    - Direct Turing machine construction is complex
    - Easier: use Python-to-Turing machine equivalence
    - Universal Python program proves universal Turing machine exists
    - Same computational power, different representation

:::

## Universal computation examples

::: {.incremental style="margin-top: -0.5em; font-size: 0.825em;"} 

- {{< iconify fa6-solid dna >}} **Rule 110 cellular automaton**
    - Uses only 2 symbols and 8 simple rules
    - Proven to be computationally universal
    - Can simulate any computation given proper encoding
    - Extremely simple yet infinitely powerful

:::

::: {.incremental style="margin-top: -0.5em; font-size: 0.825em;"}

- {{< iconify fa6-solid globe >}} **Conway's Game of Life**
    - Simple rules govern cell birth, death, survival
    - Turing-complete: can compute anything computable
    - Universal computation emerges from local interactions
    - Potential natural occurrences in molecular systems

:::

## Levels of computational abstraction

::: {.fragment style="margin-top: -0.2em; font-size: 0.85em;"}


| **Analysis Type** | **Program** | **Parameters** |
|:------------------|:------------|:---------------|
| Analyze a string | `containsGAGA.py` | `"ATGAG"` |
| Analyze another program | `countLines.py` | `containsGAGA.py` |
| Simulate another program | `universal.py` | `(containsGAGA.py, "ATGAG")` |
| Simulate altered program | `alterGAGAtoTATA.py` | Modified `repeatCAorGA.py` |


:::

::: {.fragment .fade style="font-size: 0.85em;"}

- **Progression**: String analysis, program simulation, program alteration
- **Difficulty**: String analysis is easiest, program alteration is hardest
- **Power**: Simulating an altered program provides a powerful tool

:::

## Program alteration techniques

![](06-universal-programs_5.png)

## Strange `ignoreInput` program

```{python}
#| autorun: true
#| max-lines: 15
def ignore_input(in_string):
    """Ignores input, performs preset computation instead."""
    # Simulate reading from files (in practice: rf('progString.txt'))
    prog_string = """
def contains_gaga(s):
    return 'yes' if 'GAGA' in s else 'no'
"""
    # Simulate reading input file (in practice: rf('inString.txt'))
    preset_input = 'GGGGGGGTTT'
    # Execute the preset computation regardless of actual input
    local_namespace = {}
    exec(prog_string, local_namespace)
    return local_namespace['contains_gaga'](preset_input)

# Input is ignored - always same result
print(ignore_input('GAGAGA'))     # Ignores this input
print(ignore_input('ANYTHING'))   # Ignores this input too
```

## Program to ignore input

![](06-universal-programs_8.png)

## Recognizable versus decidable

::: {.incremental style="margin-top: -0.5em; font-size: 0.825em;"} 

- {{< iconify fa6-solid check >}} **Recognizable problems**
    - Program correctly handles all positive instances
    - May loop forever on negative instances
    - `yesOnString` and `crashOnString` are recognizable
    - Universal simulation enables recognition

:::

## Why universal computation matters

::: {.incremental style="margin-top: -0.5em; font-size: 0.825em;"} 

- {{< iconify fa6-solid lightbulb >}} **Theoretical foundations**
    - Proves existence of problems beyond computation
    - Shows limits of what any computer can solve
    - Enables rigorous mathematical analysis of computation
    - Foundation for complexity theory and decidability

:::

::: {.incremental style="margin-top: -0.5em; font-size: 0.825em;"}

- {{< iconify fa6-solid rocket >}} **Practical implications**
    - Interpreters, compilers, virtual machines
    - Emulation and simulation systems
    - Program analysis and transformation tools
    - Understanding computational boundaries

:::

## Programming universal behavior

::: {.fragment style="margin-top: -0.5em; font-size: 0.85em;"}

```{pyodide}
#| autorun: true
#| max-lines: 20
def simple_universal(program_code, input_data):
    """A simplified universal program for proofgrammers."""
    try:
        # Create a safe execution environment
        namespace = {}
        
        # Execute the program definition
        exec(program_code, namespace)
        
        # Find the main function (assume it's the first defined function)
        main_function = None
        for name, obj in namespace.items():
            if callable(obj) and not name.startswith('_'):
                main_function = obj
                break
        
        if main_function:
            return main_function(input_data)
        else:
            return "No function found"
            
    except Exception as e:
        return f"Error: {e}"

# Test with a sample program
test_program = """
def count_vowels(text):
    vowels = 'aeiouAEIOU'
    return str(len([c for c in text if c in vowels]))
"""

result = simple_universal(test_program, "Hello World")
print(f"Vowel count: {result}")
```

:::

::: {.fragment .fade .boxed-content style="font-size: 1.0em;"}
**Proofgrammers**: Express universal computation as executable Python!
:::

## Universal programs: infinite possibilities

::: {.incremental style="margin-top: -0.5em; font-size: 0.825em;"} 

- {{< iconify fa6-solid infinity >}} **Universal capability**
    - Any program can be simulated by a universal program
    - Python's `exec()` and Turing machines both achieve universality
    - Foundation for all modern computing systems
    - Bridge between theoretical and practical computation

:::

::: {.incremental style="margin-top: -0.5em; font-size: 0.825em;"}

- {{< iconify fa6-solid code >}} **Proofgrammer applications**
    - Implement universal simulators in Python
    - Understand program analysis and transformation
    - Explore the boundaries of computation
    - Connect abstract theory to concrete programming

:::

::: {.fragment .fade .boxed-content style="font-size: 1.0em;"}
**Next**: Apply universal computation to prove fundamental limits!
:::
