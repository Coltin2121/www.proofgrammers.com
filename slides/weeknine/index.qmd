---
title: "Understanding Nondeterminism"
description: "Nondeterminism does not aid computability"
date: "2025-10-20"
date-format: long
author: Gregory M. Kapfhammer
execute:
  echo: true
format:
  live-revealjs:
    completion: true
    theme: default
    css: ../css/styles.css
    history: false
    scrollable: true
    transition: slide
    highlight-style: github
    footer: "Proofgrammers"
---

# Learning objectives

::: {.fragment .callout-note icon=true title="Learning Objectives"}

- **CS-204-1**: Use intuitive analysis and proof techniques to
distinguish between tractable, intractable, and uncomputable problems.
- **CS-204-2**: Correctly use Turing machine variants to describe and
analyze computational problem solutions.
- **CS-204-5**: Apply theoretical insights about limits of computation
to implement correct and efficient Python programs.

:::

# Nondeterminism helps understand computational limits but does not increase power!

::: fragment

- Nondeterminism connects to **CS-204-1** and **CS-204-2**, helping you
understand computational power limits. **Let's explore!**

:::

## What is nondeterminism?

::: {.incremental style="margin-top: -0.5em; font-size: 0.9em;"}

- {{< iconify fa6-solid microchip >}} Modern computers appear to do
many things simultaneously
- {{< iconify fa6-solid clock >}} Pre-2000: single-core CPUs switched
between programs every few milliseconds
- {{< iconify fa6-solid shuffle >}} **Nondeterminism**: Next step could
advance any current task
- {{< iconify fa6-solid question-circle >}} **Key question**: Does
multitasking increase computational power?

:::

::: {.fragment .fade .boxed-content style="font-size: 1.0em;"}

{{< iconify fa6-solid lightbulb >}} Answer: No! Nondeterminism aids
efficiency but not computability

:::

## Nondeterministic Python with threads

::: {.incremental style="margin-top: -0.5em; font-size: 0.9em;"}

- {{< iconify fa6-brands python >}} Python's `threading` module creates
nondeterministic programs
- {{< iconify fa6-solid dna >}} **Example**: `ContainsNANA` searches
for genetic patterns (CACA, GAGA, TATA, AAAA)
- {{< iconify fa6-solid layer-group >}} Launch all four searches
simultaneously in separate threads
- {{< iconify fa6-solid forward >}} Return "yes" as soon as any thread
finds a match

:::

::: {.fragment .fade .boxed-content style="font-size: 1.0em;"}

{{< iconify fa6-solid rocket >}} Nondeterministic approach potentially
faster than sequential search

:::

## Deterministic solution for `ContainsNANA`

```{python}
def containsNANA(inString):
    strings = ['CACA', 'GAGA', 'TATA', 'AAAA']
    for string in strings:
        if string in inString:
            return 'yes'
    return 'no'

assert containsNANA('CCCTATACCCGAGACCC') == 'yes'
assert containsNANA('CCCGGGCCC') == 'no'
print(containsNANA('CCCTATACCCGAGACCC'))
print(containsNANA('CCCGGGCCC'))
```

::: {.fragment .fade .boxed-content style="font-size: 1.0em;"}

{{< iconify fa6-solid arrow-right >}} Sequential: search one string at
a time

:::

## Nondeterministic `ContainsNANA` structure

```{python}
from threading import Thread

def ndContainsNANA(inString):
    strings = ['CACA', 'GAGA', 'TATA', 'AAAA']
    threads = []
    ndSoln = utils.NonDetSolution()
    for s in strings:
        t = Thread(target=findString, args=(s, inString, ndSoln))
        threads.append(t)
    solution = utils.waitForOnePosOrAllNeg(threads, ndSoln)
    return solution
```

::: {.fragment .fade .boxed-content style="font-size: 1.0em;"}

{{< iconify fa6-solid graduation-cap >}} Focus on nondeterminism
concept, not multithreaded programming details

:::

## Computation trees visualize nondeterminism

![](08-nondeterminism_4.png)

::: {.incremental style="margin-top: -0.5em; font-size: 0.9em;"}

- {{< iconify fa6-solid sitemap >}} **Nodes**: Represent threads;
**Root**: Initial thread
- {{< iconify fa6-solid leaf >}} **Leaves**: Threads that return "yes",
"no", or never terminate
- {{< iconify fa6-solid check >}} Any positive leaf: output is positive
- {{< iconify fa6-solid x >}} All leaves negative: output is "no"

:::

::: {.fragment .fade .boxed-content style="font-size: 1.0em;"}

{{< iconify fa6-solid key >}} "One-positive-or-all-negative" defines
nondeterministic output

:::

## Example computation tree

![](08-nondeterminism_0.png)

::: {.fragment .fade .boxed-content style="font-size: 1.0em;"}

{{< iconify fa6-solid dna >}} Input "CCCTATACCCGAGACCC" has two
positive leaves returning "yes"

:::

## Claim 8.1: nondeterminism does not add power

::: {.fragment style="margin-top: -0.5em; font-size: 0.9em;"}

{{< iconify fa6-solid scale-balanced >}} **Claim 8.1**: Any problem
computable by a nondeterministic Python program can also be computed by
a deterministic Python program.

:::

::: {.fragment .fade .boxed-content style="font-size: 1.0em;"}

{{< iconify fa6-solid key >}} Nondeterminism aids efficiency but not
computational power

:::

## Proof sketch of Claim 8.1

::: {.incremental style="margin-top: -0.5em; font-size: 0.9em;"}

- {{< iconify fa6-solid play >}} Deterministically simulate
nondeterminism by switching between tasks
- {{< iconify fa6-solid list >}} Add each new thread to task list
- {{< iconify fa6-solid check >}} If any positive leaf exists: simulation
eventually reaches it
- {{< iconify fa6-solid desktop >}} Pre-2000 single-core computers
proved this works in practice

:::

::: {.fragment .fade .boxed-content style="font-size: 1.0em;"}

{{< iconify fa6-solid triangle-exclamation >}} Nondeterminism may
greatly improve efficiency despite not changing computability

:::

## Nondeterministic Turing machines

::: {.incremental style="margin-top: -0.5em; font-size: 0.9em;"}

- {{< iconify fa6-solid clone >}} Standard Turing machine that can clone
itself
- {{< iconify fa6-solid tape >}} Each clone has same tape and state
- {{< iconify fa6-solid arrow-right >}} Each clone follows different
transition
- {{< iconify fa6-solid book >}} Formalism enables rigorous mathematical
proofs

:::

::: {.fragment .fade .boxed-content style="font-size: 1.0em;"}

{{< iconify fa6-solid key >}} Nondeterministic TMs formalize
multithreaded computation

:::

## Example: `GthenOneT` problem

::: {.incremental style="margin-top: -0.5em; font-size: 0.9em;"}

- {{< iconify fa6-solid input-text >}} Input: Genetic string bracketed
by x's
- {{< iconify fa6-solid check >}} Accept if some "G" has exactly one "T"
between G and either end
- {{< iconify fa6-solid clone >}} When G found: create three clones
    - Check left for one T
    - Check right for one T
    - Continue searching for next G

:::

::: {.fragment .fade .boxed-content style="font-size: 1.0em;"}

{{< iconify fa6-solid example >}} "xATGTTx" accepted; "xATTGx" rejected

:::

## Nondeterministic Turing machine diagram

![](08-nondeterminism_7.png)

::: {.fragment .fade .boxed-content style="font-size: 1.0em;"}

{{< iconify fa6-solid diagram-project >}} State $q_1$ has ambiguous
transitions: multiple valid next states when scanning G

:::

## Computation tree for `GthenOneT`

![](08-nondeterminism_9.png)

::: {.fragment .fade .boxed-content style="font-size: 1.0em;"}

{{< iconify fa6-solid check >}} Input "xTGTGGTx": three leaves accept,
so result is accept

:::

## Formal definition: transition functions

::: {.incremental style="margin-top: -0.5em; font-size: 0.9em;"}

- {{< iconify fa6-solid book >}} **Deterministic**: $(q, x) \mapsto
(q', x', d')$ returns single 3-tuple
- {{< iconify fa6-solid list >}} **Nondeterministic**: $(q, x) \mapsto
\{(q'_1, x'_1, d'_1), (q'_2, x'_2, d'_2), \ldots\}$ returns set of
3-tuples
- {{< iconify fa6-solid one >}} Singleton sets behave deterministically
- {{< iconify fa6-solid clone >}} Multiple elements enable cloning

:::

::: {.fragment .fade .boxed-content style="font-size: 1.0em;"}

{{< iconify fa6-solid lightbulb >}} Only difference: sets instead of
single values

:::

## Claim 8.3: equivalence of models

::: {.fragment style="margin-top: -0.5em; font-size: 0.9em;"}

{{< iconify fa6-solid scale-balanced >}} **Claim 8.3**: Given a
nondeterministic Turing machine $M$ that solves problem $P$, there
exists a deterministic Turing machine $M'$ that also solves $P$.

:::

::: {.fragment .fade .boxed-content style="font-size: 1.0em;"}

{{< iconify fa6-solid triangle-exclamation >}} Same computability but
potentially vastly different efficiency

:::

## Three models of nondeterminism

::: {.incremental style="margin-top: -0.5em; font-size: 0.9em;"}

- {{< iconify fa6-solid layer-group >}} **Simultaneous threads**:
Execute all threads simultaneously (book's model)
- {{< iconify fa6-solid dice >}} **Random choice**: Choose one transition
at random
- {{< iconify fa6-solid user >}} **External choice**: External operator
chooses transition

:::

::: {.fragment .fade .boxed-content style="font-size: 1.0em;"}

{{< iconify fa6-solid equals >}} All three produce identical computation
trees and results

:::

## Unrecognizable problems via nondeterminism

::: {.fragment style="margin-top: -0.5em; font-size: 0.9em;"}

{{< iconify fa6-solid scale-balanced >}} **Claim 8.4**: The complement
of a recognizable, undecidable decision problem is unrecognizable.

:::

::: {.incremental style="margin-top: -0.5em; font-size: 0.85em;"}

- {{< iconify fa6-solid clone >}} **Proof idea**: Create
nondeterministic program executing both $P_1$ (for $D$) and $P_2$ (for
$\overline{D}$) in parallel
- {{< iconify fa6-solid x >}} If both recognizable: combined program
decides $D$, contradicting undecidability
- {{< iconify fa6-solid example >}} `NotYesOnString` is unrecognizable

:::

## Why study nondeterminism?

::: {.incremental style="margin-top: -0.5em; font-size: 0.9em;"}

- {{< iconify fa6-solid brain >}} Easier to analyze and prove results
(e.g., Claim 8.4)
- {{< iconify fa6-solid server >}} Models real systems (web search
engines use hundreds of computers)
- {{< iconify fa6-solid key >}} Foundation for NP-completeness theory
(Chapter 14)
- {{< iconify fa6-solid lock >}} Example: integer factorization easy
nondeterministically, hard deterministically

:::

::: {.fragment .fade .boxed-content style="font-size: 1.0em;"}

{{< iconify fa6-solid graduation-cap >}} Nondeterminism: powerful
conceptual tool for complexity theory

:::

## Key takeaways

::: {.incremental style="margin-top: -0.5em; font-size: 0.9em;"}

- {{< iconify fa6-solid x >}} Nondeterminism does not increase
computational power
- {{< iconify fa6-solid tachometer-alt >}} Nondeterminism can greatly
improve efficiency
- {{< iconify fa6-solid sitemap >}} Computation trees visualize
nondeterministic execution
- {{< iconify fa6-solid clone >}} Nondeterministic TMs formalize the
concept mathematically
- {{< iconify fa6-solid graduation-cap >}} Foundation for complexity
theory and NP-completeness

:::

::: {.fragment .fade .boxed-content style="font-size: 1.0em;"}

{{< iconify fa6-solid lightbulb >}} Nondeterminism aids efficiency and
proofs, not computability

:::
