---
title: "Turing Machines"
description: "Understanding the 'simplest' computer's power"
date: "2025-09-22"
date-format: long
author: Gregory M. Kapfhammer
execute:
  echo: true
format:
  live-revealjs:
    completion: true
    theme: default
    css: ../css/styles.css
    history: false
    scrollable: true
    transition: slide
    highlight-style: github
    footer: "Proofgrammers"
---

# Simplest possible computer? How to define? Benefits?

::: fragment

- Define the Turing machine
- Explain how it works
- Explore universal computation
- Connect to Python programming

:::

## Wait, why not just use Python?

::: incremental

- {{< iconify fa6-brands python >}} Python is great for practical programming
- {{< iconify fa6-solid gear >}} Running a Python program depends on:
  - {{< iconify fa6-solid desktop >}} Operating system
  - {{< iconify fa6-solid code >}} Python interpreter
  - {{< iconify fa6-solid boxes-stacked >}} Python libraries
  - {{< iconify fa6-solid microchip >}} Hardware architecture
- {{< iconify fa6-solid shield-halved >}} Completely rigorous proofs require more guarantees
- {{< iconify fa6-solid robot >}} The Turing machine provides a simple, idealized model

:::

## Meet the Turing machine

::: {.incremental style="margin-top: -0.5em; font-size: 0.825em;"} 

- {{< iconify fa6-solid cube >}} **What is a Turing machine?**
    - **Mathematical model**: formal definition of computation
    - **Simplest computer**: only basic operations needed
    - **Universal power**: can compute anything computable
    - **Historical significance**: foundation of computer science

:::

::: {.incremental style="margin-top: -0.5em; font-size: 0.825em;"}

- {{< iconify fa6-solid lightbulb >}} **Why study Turing machines?**
    - Understand fundamental limits of computation
    - Bridge abstract theory and concrete programming
    - Prove what problems are solvable or unsolvable
    - Foundation for complexity theory and analysis

:::

## Turing machine components

::: {.incremental style="margin-top: -0.15em; font-size: 0.8em;"}

- {{< iconify fa6-solid gear >}} **Physical metaphor of a "tape machine"**
  - **Infinite tape**: divided into cells, each holds one symbol
  - **Read/write head**: can read, write, and move left/right or stay
  - **Control unit**: finite state machine controlling behavior
  - **State dial**: shows current state of the machine
- {{< iconify fa6-solid gear >}} **Operations per step**
    - **Read** the symbol under the head
    - **Write** a new symbol (or keep the same one)
    - **Move** head left, right, or stay in place
    - **Change** to a new state (or stay in same state)

:::

## A Turing machine is amazingly simple: just tape, head, and state control. Yet it can compute anything that any computer can! Wow, this is incredible!

::: incremental

- Turing machines are "simpler" than real computers
- Yet, they can compute **anything** that is computable
- Their simplicity allows for **deep theoretical** insights
- Now, we can **mathematically define** a Turing machine
- **Get ready, this is going to be both challenging and fun!**

:::

## Formal Turing machine definition

::: {.incremental style="margin-top: -0.15em; font-size: 0.7em;"}

- {{< iconify fa6-solid cog >}} **Alphabet $\Sigma$**: finite set of symbols
always including the blank symbol $\sqcup$
- {{< iconify fa6-solid cog >}} **State set $Q$**: finite set including start
state $q_0$ and halting/accept/reject states
- {{< iconify fa6-solid cog >}} **Transition function $\delta$** defined
as $\delta(q, x) = (q', x', d')$
  - **Input**: current state $q \in Q$ and scanned symbol $x \in \Sigma$
  - **Output**:
     - New state $q' \in Q$
     - New symbol $x' \in \Sigma$
     - New direction $d' \in \{L, R, S\}$
- **Halting states**
    - $q_{accept}$: halt and computation accepts the input
    - $q_{reject}$: halt and computation rejects the input  
    - $q_{halt}$: halt without acceptance or rejection of input

:::

## Simple example: `lastTtoA` machine

::: {.incremental style="margin-top: -0.15em; font-size: 0.85em;"}

- {{< iconify fa6-solid dna >}} **Goal**: Change the last T in a DNA string to A
- {{< iconify fa6-solid dna >}} **Algorithm outline**:
  1. Start in $q_0$, move right to end of string designated by $\sqcup$
  2. Move to $q_1$, scan left looking for a T, which must be the last one
  3. When T is found, replace it with A and then halt the machine
- {{< iconify fa6-solid dna >}} **Examples**:
  - CTCGTA → CTCGAA
  - CGAT → CGAA
  - TTTT → TTTA
  - *Wait*, what would happen with GGGG? We will explain this soon!

:::

## Turing machine computation example

::: {style="margin-top: -0.2em; font-size: 0.725em;"}

**Trace of `lastTtoA` on input CTCGTA**:

```
Step 1: q₀: [C] T C G T A        (start, head at position 0)
Step 2: q₀: C [T] C G T A        (read C, write C, move right)
Step 3: q₀: C T [C] G T A        (read T, write T, move right)
Step 4: q₀: C T C [G] T A        (read C, write C, move right)
Step 5: q₀: C T C G [T] A        (read G, write G, move right)
Step 6: q₀: C T C G T [A]        (read T, write T, move right)
Step 7: q₀: C T C G T A [⊔]      (read A, write A, move right)
Step 8: q₁: C T C G T [A] ⊔      (read ⊔, write ⊔, move left)
Step 9: q₁: C T C G [T] A ⊔      (read A, write A, move left)
Step 10: qₕₐₗₜ: C T C G [A] A ⊔  (read T, write A, stay, halt)
```

:::

::: {.fragment .fade style="font-size: 0.65em;"}

- **This simple Turing machine demonstrates key concepts**:
    - Reading and processing input
    - Moving the read/write head
    - Producing output by writing a new symbol
- **Result**: Input CTCGTA becomes the output CTCGAA!

:::

## Simple Turing machine simulator

```{pyodide}
#| autorun: true
#| max-lines: 10
class TuringMachine:
    """Simple Turing machine simulator for proofgrammers."""
    
    def __init__(self, transitions, start_state='q0', blank='⊔'):
        self.transitions = transitions
        self.state = start_state
        self.blank = blank
        self.reset()
    
    def reset(self):
        """Reset machine to initial configuration."""
        self.tape = []
        self.head = 0
        self.state = 'q0'
        self.steps = 0
    
    def load_input(self, input_string):
        """Load input string onto tape."""
        self.tape = list(input_string) + [self.blank]
        self.head = 0

# Define lastTtoA transitions
last_t_to_a_transitions = {
    ('q0', 'C'): ('q0', 'C', 'R'),
    ('q0', 'T'): ('q0', 'T', 'R'),
    ('q0', 'G'): ('q0', 'G', 'R'),
    ('q0', 'A'): ('q0', 'A', 'R'),
    ('q0', '⊔'): ('q1', '⊔', 'L'),
    ('q1', 'C'): ('q1', 'C', 'L'),
    ('q1', 'G'): ('q1', 'G', 'L'),
    ('q1', 'A'): ('q1', 'A', 'L'),
    ('q1', 'T'): ('qhalt', 'A', 'S')
}

# create the machine for follow-on simulation
tm = TuringMachine(last_t_to_a_transitions)
print("Created lastTtoA Turing machine!")
print("Transitions loaded:", len(last_t_to_a_transitions))
```

::: {.fragment .fade-up style="font-size: 0.75em;"}

- Map: `(state, symbol)` to `(new_state, new_symbol, direction)`
- Next we must **define** functions to **run** the machine for an **input**
- Create **simple simulator** that any proofgrammer can extend!

:::

## Run the simple simulator

```{pyodide}
#| autorun: true
#| max-lines: 6
def step(tm):
    """Execute one step of Turing machine computation."""
    if tm.head >= len(tm.tape):
        tm.tape.extend([tm.blank] * (tm.head - len(tm.tape) + 1))
    current_symbol = tm.tape[tm.head]
    key = (tm.state, current_symbol)
    if key not in tm.transitions:
        return False  # halt if no transition defined
    new_state, new_symbol, direction = tm.transitions[key]
    tm.tape[tm.head] = new_symbol
    tm.state = new_state
    # move head
    if direction == 'L' and tm.head > 0:
        tm.head -= 1
    elif direction == 'R':
        tm.head += 1
    # 'S' means stay
    tm.steps += 1
    return tm.state not in ['qhalt', 'qaccept', 'qreject']

def run_machine(tm, input_string, max_steps=100):
    """Run Turing machine on input string."""
    tm.reset()
    tm.load_input(input_string)
    print(f"Input: {input_string}")
    print(f"Step 0: {tm.state}: {format_configuration(tm)}")
    while step(tm) and tm.steps < max_steps:
        if tm.steps <= 10:  # Show first 10 steps
            print(f"Step {tm.steps}: {tm.state}: {format_configuration(tm)}")
    output = ''.join(tm.tape).rstrip(tm.blank)
    print(f"Final: {tm.state}: {format_configuration(tm)} with Output: {output}")
    return output

def format_configuration(tm):
    """Format current configuration for display."""
    tape_str = ''.join(tm.tape[:tm.head]) + '[' + tm.tape[tm.head] + ']'
    if tm.head + 1 < len(tm.tape):
        tape_str += ''.join(tm.tape[tm.head+1:])
    return tape_str.rstrip(tm.blank)

# test the machine with an input
result = run_machine(tm, "CTCGTA")
```

## Halting and looping

::: {.incremental .fade-right style="font-size: 0.9em;"}

- The `lastTtoA` machine halts under these assumptions:
    - Input only contains symbols in {A, C, G, T}
    - Input contains at least one T
- What about the input of "CGGA" or "GGGG"?
    - The machine gets stuck in state $q_1$
    - The machine will never reach a halting state
- A Turing machine that runs forever is said to **loop**
- If a Turing machine is **not looping** we say it **halts**
- If it halts, then it may **accept** or **reject**, or **simply halt**

:::

## Type of Turing machines

::: {.incremental style="margin-top: -0.15em; font-size: 0.95em;"}

- An acceptor **accepts** or **rejects** its input:
  - Always halts in either $q_{accept}$ or $q_{reject}$
- A transducer **transforms** its input:
    - Always halts in $q_{halt}$
    - Output is the tape contents when halted
    - Output does not include the blank symbol $\sqcup$
- Turing machines can act as:
    - Acceptor or transducer
    - Both acceptor and transducer

:::

## The `containsGAGA` acceptor machine

::: {.incremental style="margin-top: -0.15em; font-size: 0.775em;"}

- {{< iconify fa6-solid search >}} **Goal**: Accept strings containing "GAGA"
substring
- {{< iconify fa6-solid search >}} **Alphabet**: {A, C, G, T, ⊔} (i.e., DNA
characters and the special blank symbol)
- {{< iconify fa6-solid search >}} **Machine type**: acceptor, not transducer
  - Outputs accept/reject decision, not a modified string
  - Uses states $q_{accept}$ and $q_{reject}$ instead of $q_{halt}$
- {{< iconify fa6-solid search >}} **Strategy**: scan string left-to-right,
track partial matches
- {{< iconify fa6-solid search >}} **High-level Examples**:
  - GAGA → ACCEPT
  - CGAGAT → ACCEPT
  - GATACA → REJECT
  - GGAGAGA → ACCEPT

:::

## Understanding `containsGAGA` states

::: {.fragment style="margin-top: -0.15em; font-size: 0.75em;"}

**State meanings for `containsGAGA`**:

- {{< iconify fa6-solid search >}} **States**: $q_0, q_1, q_2, q_3, q_{accept}, q_{reject}$
    - $q_0$: haven't seen G, or just saw non-G character
    - $q_1$: just saw first G (i.e., looking for A)
    - $q_2$: saw GA (i.e., looking for second G)  
    - $q_3$: saw GAG (i.e., looking for final A)
    - $q_{accept}$: found complete GAGA pattern
    - $q_{reject}$: reached end without finding GAGA

:::

::: {.fragment .fade .boxed-content style="font-size: 0.85em;"}

{{< iconify fa6-solid lightbulb >}} Pattern matching is fundamental to many
computational problems. Critically, Turing machines can solve any pattern
recognition task!

:::

## `containsGAGA` diagram

![State diagram for the `containsGAGA` Turing machine.](05-turing-machines_7.png)

## Acceptor versus transducer machines

::: {.incremental style="margin-top: -0.35em; font-size: 0.725em;"}

- {{< iconify fa6-solid input-output >}} **Transducer Turing machines:**  
    - Transform input string to output string
    - Like functions: input → output
    - Use $q_{halt}$ state and read final tape contents
    - Example: `lastTtoA` changes CTCGTA to CTCGAA
    - Like a SISO program that returns an arbitrary string

- {{< iconify fa6-solid check-circle >}} **Acceptor Turing machines:**  
    - Make accept/reject decisions about input
    - Like boolean functions: input → true/false
    - Use $q_{accept}$ and $q_{reject}$ states
    - Example: `containsGAGA` accepts/rejects DNA strings
    - Like a SISO program that only returns "yes"/"no"

:::

## Simulate `containsGAGA` in Python

```{pyodide}
#| autorun: true
#| max-lines: 8
# Define containsGAGA Turing machine transitions
contains_gaga_transitions = {
    # From q0 (initial state)
    ('q0', 'G'): ('q1', 'G', 'R'),  # Found first G
    ('q0', 'C'): ('q0', 'C', 'R'),  # Continue scanning
    ('q0', 'A'): ('q0', 'A', 'R'),  # Continue scanning  
    ('q0', 'T'): ('q0', 'T', 'R'),  # Continue scanning
    ('q0', '⊔'): ('qreject', '⊔', 'S'),  # End without GAGA
    # From q1 (saw G)
    ('q1', 'A'): ('q2', 'A', 'R'),  # GA found
    ('q1', 'G'): ('q1', 'G', 'R'),  # Still in G state
    ('q1', 'C'): ('q0', 'C', 'R'),  # Reset
    ('q1', 'T'): ('q0', 'T', 'R'),  # Reset
    ('q1', '⊔'): ('qreject', '⊔', 'S'),
    # From q2 (saw GA)
    ('q2', 'G'): ('q3', 'G', 'R'),  # GAG found
    ('q2', 'A'): ('q0', 'A', 'R'),  # Reset
    ('q2', 'C'): ('q0', 'C', 'R'),  # Reset
    ('q2', 'T'): ('q0', 'T', 'R'),  # Reset
    ('q2', '⊔'): ('qreject', '⊔', 'S'),
    # From q3 (saw GAG)
    ('q3', 'A'): ('qaccept', 'A', 'S'),  # GAGA found!
    ('q3', 'G'): ('q1', 'G', 'R'),  # New G sequence
    ('q3', 'C'): ('q0', 'C', 'R'),  # Reset
    ('q3', 'T'): ('q0', 'T', 'R'),  # Reset
    ('q3', '⊔'): ('qreject', '⊔', 'S')
}

# Create the accepter machine
gaga_tm = TuringMachine(contains_gaga_transitions)
# Test cases for GAGA detection
test_cases = ["GAGA", "CGAGAT", "GATACA", "GGAGAGA"]
for test in test_cases:
    gaga_tm.reset()
    gaga_tm.load_input(test)
    # Run until halt
    while step(gaga_tm) and gaga_tm.steps < 50:
        pass
    decision = "ACCEPT" if gaga_tm.state == "qaccept" else "REJECT"
    print(f"Input: {test:<8} → {decision}")
```

::: {.fragment .fade-up style="margin-top: -0.25em; font-size: 0.7em;"}

- Simulation of the `containsGAGA` acceptor Turing machine
- Illustrates pattern matching with state-based memory
- Demonstrates accept/reject computation model for proofgrammers!

:::

## The `moreCsThanGs` acceptor machine

::: {.incremental style="margin-top: -0.15em; font-size: 0.775em;"}

- {{< iconify fa6-solid dna >}} **Problem**: Determine if DNA string has more C's than G's
- {{< iconify fa6-solid gear >}} **Algorithm strategy**: Use cancellation approach
    - Find a G, mark it, look for C to cancel it
    - Find a C, mark it, look for G to cancel it  
    - If C's remain after all G's cancelled → accept
    - Otherwise reject (more G's or equal counts)
- {{< iconify fa6-solid dna >}} **Examples**:
    - CCGG → REJECT (equal counts)
    - CCGGC → ACCEPT (more C's)
    - CGCGC → ACCEPT (more C's)
    - GGCCG → REJECT (more G's)

:::

## Simulate `moreCsThanGs` in Python

```{pyodide}
#| autorun: true
#| max-lines: 12
# moreCsThanGs Turing machine from textbook
more_cs_than_gs_transitions = {
    # From q0 - scan right looking for unmarked C or G
    ('q0', 'x'): ('q1', 'x', 'R'),
    # From q1 - main scanning state
    ('q1', 'z'): ('q1', 'z', 'R'),  # Skip marked symbols
    ('q1', 'T'): ('q1', 'T', 'R'),  # Skip T
    ('q1', 'A'): ('q1', 'A', 'R'),  # Skip A
    ('q1', 'G'): ('q2', 'z', 'R'),  # Found G, mark it, look for C
    ('q1', 'C'): ('q3', 'z', 'R'),  # Found C, mark it, look for G
    ('q1', 'x'): ('qreject', 'x', 'S'),  # End marker, reject
    # From q2 - marked G, looking for C to cancel
    ('q2', 'z'): ('q2', 'z', 'R'),  # Skip marked
    ('q2', 'T'): ('q2', 'T', 'R'),  # Skip T
    ('q2', 'A'): ('q2', 'A', 'R'),  # Skip A  
    ('q2', 'G'): ('q2', 'G', 'R'),  # Skip unmarked G
    ('q2', 'C'): ('q4', 'z', 'L'),  # Found C to cancel, go back
    ('q2', 'x'): ('qreject', 'x', 'S'),  # No C found, reject
    # From q3 - marked C, looking for G to cancel
    ('q3', 'z'): ('q3', 'z', 'R'),  # Skip marked
    ('q3', 'T'): ('q3', 'T', 'R'),  # Skip T
    ('q3', 'A'): ('q3', 'A', 'R'),  # Skip A
    ('q3', 'C'): ('q3', 'C', 'R'),  # Skip unmarked C
    ('q3', 'G'): ('q4', 'z', 'L'),  # Found G to cancel, go back  
    ('q3', 'x'): ('qaccept', 'x', 'S'),  # No G found, accept
    # From q4 - return to start after cancelling pair
    ('q4', 'x'): ('q1', 'x', 'R'),  # Found start, continue
    ('q4', 'z'): ('q4', 'z', 'L'),  # Move left through anything
    ('q4', 'T'): ('q4', 'T', 'L'),
    ('q4', 'A'): ('q4', 'A', 'L'),
    ('q4', 'C'): ('q4', 'C', 'L'),
    ('q4', 'G'): ('q4', 'G', 'L')
}

# Create the accepter machine  
more_cs_tm = TuringMachine(more_cs_than_gs_transitions)
# Test cases for comparing C and G counts
test_cases = ["xCCGx", "xGGCx", "xCGCx", "xGCGx", "xCCCGGx"]
for test in test_cases:
    more_cs_tm.reset()
    more_cs_tm.load_input(test)
    # Run until halt
    while step(more_cs_tm) and more_cs_tm.steps < 100:
        pass
    decision = "ACCEPT" if more_cs_tm.state == "qaccept" else "REJECT" 
    c_count = test.count('C')
    g_count = test.count('G')
    print(f"Input: {test:<8} (C:{c_count}, G:{g_count}) → {decision}")
```


## Textual representation

```text
q0->q1: x;R
q1->q1: zTA;R
q1->q2: G;z,R
q1->q3: C;z,R
q1->qR: x;S
q2->q2: zTAG;R
q2->q4: C;z,L
q2->qR: x;S
q3->q3: zTAC;R
q3->q4: G;z,L
q3->qA: x;S
q4->q1: x;R
q4->q4: !x;L
```

::: {.incremental style="margin-top: 0.05em; font-size: 0.9em;"}

- Textbook defines a notation for representing Turing machines
- Save these rules inside of a `moreCsThanGs.tm` file
- Run in the universal simulator that we later define!

:::

## Explain `moreCsThanGs.tm`

::: {.incremental style="margin-top: -0.15em; font-size: 0.85em;"}

- {{< iconify fa6-solid code >}} **Compact notation in textbook**:
    - Each line represents a transition rule
    - `zTA` intuitively means "any symbol from {z, T, A}"
    - `zTAC` intuitively means "any symbol from {z, T, A, C}"  
    - `zTAG` intuitively means "any symbol from {z, T, A, G}"

- {{< iconify fa6-solid gear >}} **Why this notation works**:
    - `z` = marker for processed symbols
    - `T`, `A` = input symbols to skip over
    - `C`, `G` = target symbols for counting/cancelling
    - **Encodes the full Turing machine in a text file**!

:::

# From Turing machines to real computers

::: incremental

- Turing machines are simple but powerful
    - Simulate any computation
    - Extended in various ways
    - Each extension is equivalent in power
    - **Python and Turing machines are equivalent**!

:::

## Chain of simulation approach

::: {.incremental style="margin-top: -0.15em; font-size: 0.8em;"}

- Linux can run any Java virtual machine *and*
- The Java virtual machine can run any Java program
- **Visualization of this chain of simulation**:
    - Linux → Java VM → Java program

:::

::: {.incremental style="margin-top: -0.25em; font-size: 0.8em;"}

- **Visualization of this chain of simulation for Turing machines**:
    - one-tape TM → multi-tape, single-head TM
    - multi-tape, single-head TM → multi-tape, multi-head TM
    - multi-tape, multi-head TM → random-access TM
    - random-access TM → real, modern computer
    - real, modern computer → Python program

:::

# Chain of simulation reasoning shows we can simulate a Python program by a Turing machine! *Wow*!

## Multi-tape Turing machines

::: {.incremental style="margin-top: -0.15em; font-size: 0.825em;"}

- {{< iconify fa6-solid layer-group >}} **Extensions beyond single tape**
    - **Two-tape machines**: separate input and output tapes
    - **Multi-tape machines**: several tapes for different purposes
    - **Two-way infinite tapes**: extend infinitely in both directions
    - **Multi-head machines**: multiple read/write heads per tape

- {{< iconify fa6-solid lightbulb >}} **Why extend the basic model?**
    - Makes "programming" more natural and efficient
    - Closer to real computer architectures
    - Separates input, working memory, and output
    - **Still equivalent in computational power**!

:::

## Turing machines to Python programs

::: {.incremental style="margin-top: -0.15em; font-size: 0.785em;"}

- {{< iconify fa6-solid arrow-right >}} **Multi-tape TM → Random-access TM**
    - Add random access to any tape position
    - Like having addressable memory locations
- {{< iconify fa6-solid arrow-right >}} **Random-access TM → Real computer**
    - Add arithmetic operations and finite memory
    - Modern CPU with RAM and instruction set
- {{< iconify fa6-solid arrow-right >}} **Real computer → Python program**
    - High-level programming languages and interpreters
    - The programs we write every day!
- **Church-Turing thesis**: Every "reasonable" computational model has the same 
power as Turing machines. Including programs in Python, Java, or C!

:::

## Simulating Turing machines

```{pyodide}
#| autorun: true
#| max-lines: 10
class Transition:
    """Models a transition in a Turing machine."""
    def __init__(self, sourceState, destState, label, writeSymbol, direction):
        self.sourceState = sourceState
        self.destState = destState
        self.label = label
        self.writeSymbol = writeSymbol
        self.direction = direction

class TuringMachine:
    """A simplified Turing machine simulator."""
    blank = '_'
    rightDir = 'R'
    leftDir = 'L'
    stayDir = 'S'
    acceptState = 'qA'
    rejectState = 'qR'
    startState = 'q0'
    maxSteps = 1000
    
    def __init__(self, description):
        self.transitions = {}
        self.parse_description(description)
        
    def parse_description(self, description):
        """Parse Turing machine description format like 'q0->q1: G;R'"""
        lines = [line.strip() for line in description.strip().split('\n') if line.strip()]
        for line in lines:
            # Parse format: q0->q1: G;R or q0->q0: !_G;R
            parts = line.split(':')
            states_part = parts[0].strip()
            action_part = parts[1].strip()
            source_state, dest_state = [s.strip() for s in states_part.split('->')]
            if ';' in action_part:
                label, direction = [s.strip() for s in action_part.split(';')]
                write_symbol = None
            else:
                parts = action_part.split(';')
                label = parts[0].strip()
                if len(parts) > 1:
                    direction = parts[1].strip()
                else:
                    direction = 'S'
                write_symbol = None
            transition = Transition(source_state, dest_state, label, write_symbol, direction)
            if source_state not in self.transitions:
                self.transitions[source_state] = []
            self.transitions[source_state].append(transition)
    
    def label_matches_symbol(self, symbol, label):
        """Check if symbol matches transition label."""
        if label.startswith('!'):
            # Handle negation: !_G means "not blank and not G"
            excluded = label[1:]
            return symbol not in excluded
        else:
            return symbol in label
    
    def reset(self, input_string):
        """Reset machine with input string."""
        self.tape = list(input_string) + [self.blank] * 20  # Add blanks for expansion
        self.head_pos = 0
        self.state = self.startState
        self.steps = 0
        self.halted = False
    
    def step(self):
        """Perform one computation step."""
        if self.halted or self.steps >= self.maxSteps:
            return
        current_symbol = self.tape[self.head_pos]
        valid_transitions = []
        # Find valid transitions from current state
        for transition in self.transitions.get(self.state, []):
            if self.label_matches_symbol(current_symbol, transition.label):
                valid_transitions.append(transition)
        if not valid_transitions:
            # No valid transition - implicit reject
            self.state = self.rejectState
            self.halted = True
            return
        # Apply first valid transition
        t = valid_transitions[0]
        self.state = t.destState
        if t.writeSymbol:
            self.tape[self.head_pos] = t.writeSymbol
        # Move head
        if t.direction == self.rightDir:
            self.head_pos += 1
            if self.head_pos >= len(self.tape):
                self.tape.append(self.blank)
        elif t.direction == self.leftDir and self.head_pos > 0:
            self.head_pos -= 1
        # Check for halting states
        if self.state in [self.acceptState, self.rejectState]:
            self.halted = True
        self.steps += 1
    
    def run(self):
        """Run until halt or max steps."""
        while not self.halted and self.steps < self.maxSteps:
            self.step()
        if self.state == self.acceptState:
            return "yes"
        elif self.state == self.rejectState:
            return "no"
        else:
            return "timeout"

def simulateTM(tm_description, input_string):
    """Simulate a Turing machine with given description and input."""
    tm = TuringMachine(tm_description)
    tm.reset(input_string)
    return tm.run()

# Real containsGAGA Turing machine description from textbook
contains_gaga_tm = """
q0->q0: !_G;R
q0->q1: G;R
q1->q2: A;R
q1->q0: !_A;S
q2->q3: G;R
q2->q0: !_G;S
q3->qA: A;R
q3->q0: !_A;S
"""

# Test with real Turing machine
test_cases = [
    ("CCCCCCCCCAAAAAA", "no"),
    ("CCCGAGACCAAAAAA", "yes"),
    ("GAGAXY", "yes")
]
print("Testing containsGAGA Turing machine:")
for input_str, expected in test_cases:
    result = simulateTM(contains_gaga_tm, input_str)
    print(f"Input: {input_str[:12]}{'...' if len(input_str) > 12 else ''}")
    print(f"Result: {result} (expected: {expected})")
```


## Universal Turing machines

::: {.incremental style="margin-top: -0.15em; font-size: 0.7em;"}

- {{< iconify fa6-solid microchip >}} **The ultimate machine**
    - **Input**: description of any Turing machine M and input string I
    - **Output**: exactly what M would output on input I
    - **Universal computation**: one machine simulates all others

- {{< iconify fa6-solid lightbulb >}} **How it works**
    - Encode machine description as a string
    - Use multiple tapes to simulate M's computation
    - Step through M's transitions systematically
    - Universal TM = "interpreter" for Turing machine language

:::

::: {.fragment .fade .boxed-content style="font-size: 0.7em;"}

**Insight**: A single, fixed Turing machine can compute anything that any
Turing machine can compute! This is the theoretical foundation of
general-purpose computers.

:::

## Church-Turing thesis

::: {.incremental style="margin-top: -0.15em; font-size: 0.7em;"}

- {{< iconify fa6-solid scale >}}{{< iconify fa6-solid check >}} **The fundamental claim of the thesis**:
    - Any function computable by "effective procedure" 
    - Can be computed by a Turing machine
    - **Informal → formal**: bridges intuitive and mathematical computation

- {{< iconify fa6-solid check >}} **Evidence supporting the thesis**:
    - All proposed models equivalent to Turing machines
    - Lambda calculus, recursive functions, cellular automata
    - Modern computers, all existing programming languages
    - No counterexample found in decades of research

:::

::: {.fragment .fade .boxed-content style="font-size: 0.7em;"}

{{< iconify fa6-solid rocket >}} **For proofgrammers**: This means studying
Turing machines teaches us about the fundamental limits of all computation,
including the Python programs we write!

:::

## Python Programs $=$ Turing Machines

::: {.incremental style="margin-top: -0.15em; font-size: 0.85em;"}

- {{< iconify fa6-brands python >}} **Every Python program can be simulated by a Turing machine**:
    - Apply the chain of simulation approach for:
      - one-tape TM → $\ldots$ → Python program
    - See textbook for more details about the chain

- {{< iconify fa6-solid code >}} **Every Turing machine can be simulated by a Python program**:
    - Write a Python interpreter for Turing machine descriptions
    - Review the simulator code and check textbook for more details

- {{< iconify fa6-solid brain >}} **Limitations of this approach to equivalence**:
    - Turing machines assume an infinite tape
    - Real computers have finite memory

:::

## Turing machines for proofgrammers

::: {.incremental style="margin-top: -0.15em; font-size: 0.75em;"}

- {{< iconify fa6-solid house >}} **Theoretical foundation**
    - Formal definition of "computation"
    - Precise statements about solvable/unsolvable problems
    - Mathematical proofs about computational limits

- {{< iconify fa6-solid code >}} **Practical connections**  
    - Every Python program corresponds to a Turing machine
    - Algorithm analysis and complexity theory
    - Understanding why some problems have no solutions

- {{< iconify fa6-solid lightbulb >}} **Proofgrammer perspective**
    - Bridge between mathematical proofs and executable code
    - Implement theoretical concepts as working programs

:::

## Summary: Turing machines as the foundation of computation

::: {.incremental style="margin-top: -0.15em; font-size: 0.8em;"}

- {{< iconify fa6-solid microchip >}} **Turing machines are**:
  - Simple mathematical models of computation
  - Universal since they can compute anything computable
  - Foundation for understanding computational limits
  
- {{< iconify fa6-solid gear >}} **Key concepts explored**:
  - Formal definition with states, alphabet, transitions
  - Transducers (input→output) versus accepters (accept/reject)
  - Multi-tape extensions and computational equivalence
  - Universal machines and Church-Turing thesis

:::

## Course learning objectives

::: {.fragment .callout-note icon=true title="Learning Objectives for Theoretical Machines"}

- **CS-204-1**: Use both intuitive analysis and theoretical proof techniques to
correctly distinguish between problems that are tractable, intractable, and
uncomputable.
- **CS-204-2**: Correctly use one or more variants of the Turing machine (TM)
abstraction to both describe and analyze the solution to a computational
problem.
- **CS-204-3**: Correctly use one or more variants of the finite statement
machine (FSM) abstraction to describe and analyze the solution to a
computational problem.
- **CS-204-4**: Use a formal proof technique to correctly classify a problem
according to whether or not it is in the P, NP, NP-Hard, and/or NP-Complete
complexity class(es).
- **CS-204-5**: Apply insights from theoretical proofs concerning the limits of
either program feasibility or complexity to the implementation of both correct
and efficient real-world Python programs.

:::

## Key takeaways

::: {.incremental style="margin-top: -0.15em; font-size: 0.75em;"}

- {{< iconify fa6-solid gear >}} **Turing Machines**: Simple model equivalent to
Python programs
- {{< iconify fa6-solid microscope >}} **Many extensions**: Variants make
"programming" simpler, but same power
- {{< iconify fa6-solid diagram-project >}} **Universal computation**:
A universal machine simulates all machines
- {{< iconify fa6-solid book-open >}} **Practical implications**: Turing
machines help to prove limits of computation

:::

::: {.fragment .fade .boxed-content style="margin-top: 0.25em; font-size: 0.8em;"}

- {{< iconify fa6-solid lightbulb >}} **Wow, this was really brain breaking! Now, you
should**:
    - Read the chapter and hand-write or type out the key results
    - Explain the key results to several members of this class
    - Explain the key results to the instructor in office hours
    - Bring your questions to the next proofgrammer charette session

:::
